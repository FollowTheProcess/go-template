PROJECT_NAME := "{{project_slug}}"
PROJECT_BIN := "./bin"
PROJECT_ENTRY_POINT := "./cmd/{{project_slug}}"
COVERAGE_DATA := "coverage.out"
COVERAGE_HTML := "coverage.html"
GORELEASER_DIST := "dist"
COMMIT_SHA := `git rev-parse HEAD`
VERSION_LDFLAG := "github.com/{{github_username}}/{{project_slug}}/cli/cmd.version"
COMMIT_LDFLAG := "github.com/{{github_username}}/{{project_slug}}/cli/cmd.commit"

# By default print the list of recipes
_default:
    @just --list

# Show justfile variables
show:
    @just --evaluate

# Tidy up dependencies in go.mod and go.sum
tidy:
    go mod tidy

# Compile the project binary
build: tidy fmt
    {% raw %}go build -ldflags="-X {{ VERSION_LDFLAG }}=dev -X {{ COMMIT_LDFLAG }}={{ COMMIT_SHA }}" -o {{ PROJECT_BIN }}/{{ PROJECT_NAME }} {{ PROJECT_ENTRY_POINT }}{% endraw %}

# Run go fmt on all project files
fmt:
    go fmt ./...

# Run all project unit tests
test *flags: fmt
    {% raw %}go test -race ./... {{ flags }}{% endraw %}

# Lint the project and auto-fix errors if possible
lint: fmt
    golangci-lint run --fix

# Calculate test coverage and render the html
cover:
    {% raw %}go test -race -cover -coverprofile={{ COVERAGE_DATA }} ./...
    go tool cover -html={{ COVERAGE_DATA }} -o {{ COVERAGE_HTML }}
    open {{ COVERAGE_HTML }}{% endraw %}

# Remove build artifacts and other project clutter
clean:
    go clean ./...
    {% raw %}rm -rf {{ PROJECT_NAME }} {{ PROJECT_BIN }} {{ COVERAGE_DATA }} {{ COVERAGE_HTML }} {{ GORELEASER_DIST }}{% endraw %}

# Run unit tests and linting in one go
check: test lint

# Print lines of code (for fun)
sloc:
    find . -name "*.go" | xargs wc -l | sort -nr

# Install the project on your machine
install: uninstall build
    {% raw %}cp {{ PROJECT_BIN }}/{{ PROJECT_NAME }} $GOBIN/{% endraw %}

# Uninstall the project from your machine
uninstall:
    {% raw %}rm -rf $GOBIN/{{ PROJECT_NAME }}{% endraw %}